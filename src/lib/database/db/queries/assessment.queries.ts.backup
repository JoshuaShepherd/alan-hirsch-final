/**
 * Assessment Query Module
 * Pure DB I/O operations for assessment with tenant scoping
 *
 * Inputs: Context with tenantId, userId, role
 * Outputs: Raw Drizzle row types (no DTOs, no mappers)
 */

import { and, eq, sql, desc, asc, like, or } from 'drizzle-orm';
import { db } from '../drizzle';
import { assessments } from '../schema';

// ============================================================================
// CONTEXT TYPE
// ============================================================================

export type Ctx = {
  tenantId: string;
  userId: string;
  role: string;
};

// ============================================================================
// ROW TYPES (from Drizzle schema)
// ============================================================================

export type AssessmentRow = typeof assessments.$inferSelect;
export type NewAssessmentRow = typeof assessments.$inferInsert;

// ============================================================================
// ASSESSMENT QUERY FUNCTIONS
// ============================================================================

/**
 * Get assessment by ID with tenant scoping
 */
export async function getAssessmentById(ctx: Ctx, id: string): Promise<AssessmentRow | null> {
  const result = await db
    .select()
    .from(assessments)
    .where(
      and(
        eq(assessments.id, id),
        sql`EXISTS (
          SELECT 1 FROM organization_memberships om
          WHERE om.organization_id = ${ctx.tenantId}
          AND om.user_id = ${ctx.userId}
          AND om.status = 'active'
        )`
      )
    )
    .limit(1);

  return result[0] || null;
}

/**
 * List assessments with pagination and filtering
 */
export async function listAssessments(
  ctx: Ctx,
  params: { q?: string; page?: number; limit?: number; sort?: string; dir?: 'asc' | 'desc' }
): Promise<{ rows: AssessmentRow[]; total: number; page: number; limit: number }> {
  const { q, page = 1, limit = 20, sort = 'createdAt', dir = 'desc' } = params;
  const offset = (page - 1) * limit;

  // Build where conditions
  const whereConditions = [
    sql`EXISTS (
      SELECT 1 FROM organization_memberships om
      WHERE om.organization_id = ${ctx.tenantId}
      AND om.user_id = ${ctx.userId}
      AND om.status = 'active'
    )`
  ];

  if (q) {
    whereConditions.push(
      or(
        like(assessments.name, `%${q}%`),
        like(assessments.description, `%${q}%`)
      )!
    );
  }

  // Get total count
  const countResult = await db
    .select({ count: sql<number>`count(*)` })
    .from(assessments)
    .where(and(...whereConditions));

  const total = countResult[0]?.count || 0;

  // Get paginated results
  const orderBy = dir === 'desc' ? desc(assessments.createdAt) : asc(assessments.createdAt);
  
  const rows = await db
    .select()
    .from(assessments)
    .where(and(...whereConditions))
    .orderBy(orderBy)
    .limit(limit)
    .offset(offset);

  return { rows, total, page, limit };
}

/**
 * Create new assessment
 */
export async function createAssessment(ctx: Ctx, input: NewAssessmentRow): Promise<AssessmentRow> {
  const result = await db
    .insert(assessments)
    .values({
      ...input,
      createdAt: new Date(),
      updatedAt: new Date(),
    })
    .returning();

  if (!result[0]) {
    throw new Error(`Failed to create assessment`);
  }

  return result[0];
}

/**
 * Update assessment by ID
 */
export async function updateAssessment(ctx: Ctx, id: string, patch: Partial<NewAssessmentRow>): Promise<AssessmentRow | null> {
  // Verify user has access to update this assessment
  const existing = await getAssessmentById(ctx, id);
  if (!existing) {
    return null;
  }

  const result = await db
    .update(assessments)
    .set({
      ...patch,
      updatedAt: new Date(),
    })
    .where(eq(assessments.id, id))
    .returning();

  return result[0] || null;
}

/**
 * Remove assessment by ID
 */
export async function removeAssessment(ctx: Ctx, id: string): Promise<boolean> {
  // Verify user has access to remove this assessment
  const existing = await getAssessmentById(ctx, id);
  if (!existing) {
    return false;
  }

  const result = await db
    .delete(assessments)
    .where(eq(assessments.id, id))
    .returning({ id: assessments.id });

  return result.length > 0;
}


/**
 * Get assessment by slug
 */
export async function getAssessmentBySlug(ctx: Ctx, slug: string): Promise<AssessmentRow | null> {
  const result = await db
    .select()
    .from(assessments)
    .where(
      and(
        eq(assessments.slug, slug),
        eq(assessments.status, 'active'),
        sql`EXISTS (
          SELECT 1 FROM organization_memberships om
          WHERE om.organization_id = ${ctx.tenantId}
          AND om.user_id = ${ctx.userId}
          AND om.status = 'active'
        )`
      )
    )
    .limit(1);

  return result[0] || null;
}

/**
 * Get assessment questions
 */
export async function getQuestions(ctx: Ctx, assessmentId: string): Promise<{ rows: any[]; total: number; page: number; limit: number }> {
  // This would need to join with assessmentQuestions table
  // For now, return empty result
  return { rows: [], total: 0, page: 1, limit: 100 };
}

